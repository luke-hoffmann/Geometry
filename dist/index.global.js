var geometry=(function(exports){'use strict';var le=i=>{throw TypeError(i)};var he=(i,e,t)=>e.has(i)||le("Cannot "+t);var s=(i,e,t)=>(he(i,e,"read from private field"),t?t.call(i):e.get(i)),u=(i,e,t)=>e.has(i)?le("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(i):e.set(i,t),c=(i,e,t,r)=>(he(i,e,"write to private field"),e.set(i,t),t);var R,L,O,y=class y{constructor(e,t,r){u(this,R);u(this,L);u(this,O);c(this,R,e),c(this,L,t),c(this,O,r);}get x(){return s(this,R)}get y(){return s(this,L)}get z(){return s(this,O)}static zero(){return new this(0,0,0)}static isVectorEqual(e,t){if(!(e instanceof y))throw Error("v1 must be a vector");if(!(t instanceof y))throw Error("v2 must be a vector");return e.x===t.x&&e.y===t.y&&t.z===t.z}static unitVector(e){if(!(e instanceof y))throw Error("v must be a vector");let t=e.magnitude();return new this(e.x/t,e.y/t,e.z/t)}static upVector(){return new this(0,0,1)}static generateVectorInSphere(e){e=Math.random()*e*e*e,e=Math.cbrt(e);let t=2,r=0,o=0,n=0;for(;t>1;)r=Math.random()*2-1,o=Math.random()*2-1,n=Math.random()*2-1,t=r*r+o*o+n*n;return new y(r*e,o*e,n*e)}static magnitude(e){if(!(e instanceof y))throw Error("p1 must be a vector");return e.magnitude()}magnitude(){return Math.hypot(this.x,this.y,this.z)}static distanceBetweenVectors(e,t){if(!(e instanceof y))throw Error("v1 must be a vector");if(!(t instanceof y))throw Error("v2 must be a vector");return Math.hypot(e.x-t.x,e.y-t.y,e.z-t.z)}static lerp(e,t,r){if(!Number.isFinite(e))throw Error("p1 is not a finite number");if(!Number.isFinite(t))throw Error("p2 is not a finite number");if(!Number.isFinite(r))throw Error("t is not a finite number");return (t-e)*r+e}static lerpVector(e,t,r){return new this(this.lerp(e.x,t.x,r),this.lerp(e.y,t.y,r),this.lerp(e.z,t.z,r))}static normalize(e){throw Error("depreciated : use Vector.unitVector(v) instead")}static crossProduct(e,t){return new this(e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x)}static dotProduct(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}static sub(e,t){return new this(e.x-t.x,e.y-t.y,e.z-t.z)}static add(e,t){return new this(e.x+t.x,e.y+t.y,e.z+t.z)}static scalarMult(e,t){return new this(e.x*t,e.y*t,e.z*t)}static rotateVector(e,t,r,o){return e=this.rotateAroundX(e,t),e=this.rotateAroundY(e,r),e=this.rotateAroundZ(e,o),e}static rotateAroundX(e,t){return new this(e.x,e.y*Math.cos(t)-e.z*Math.sin(t),e.y*Math.sin(t)+e.z*Math.cos(t))}static rotateAroundY(e,t){return new this(e.x*Math.cos(t)+e.z*Math.sin(t),e.y,-e.x*Math.sin(t)+e.z*Math.cos(t))}static rotateAroundZ(e,t){return new this(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t),e.z)}static rotate2DVector(e,t){return new this(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t),0)}isDotProductLEThanX(e,t){return y.dotProduct(this,e)<=t}copy(){return new y(s(this,R),s(this,L),s(this,O))}};R=new WeakMap,L=new WeakMap,O=new WeakMap;var a=y;var f=class{static getIndexOfArrayMax(i){if(!Array.isArray(i))throw Error("arrayOfNumbers is not an array");if(i.length==0)throw Error("arrayOfNumbers contains no elements");let e=0,t=i[0];for(let r=0;r<i.length;r++){let o=i[r];o>t&&(t=o,e=r);}return e}static isMixedUpArraysEqual(i,e){if(i.length!==e.length)return  false;i=[...i],e=[...e];for(let t=i.length-1;t>=0;t--)for(let r=e.length-1;r>=0;r--)i[t]===e[r]&&(i.splice(t,1),e.splice(r,1));return i.length==0&&e.length==0}static isThereValueGreaterThanN(i,e){for(let t of i)if(t>e)return  true;return  false}static combineArrays(i){let e=[];for(let t of i)for(let r of t)e.push(r);return e}static arrayOfIndices(i){let e=[];for(let t=0;t<i;t++)e.push(t);return e}static addToMap(i,e,t){i.has(e)||i.set(e,[]);i.get(e).push(t);return i}static incrementMap(i,e){if(!i.has(e))throw new Error("Supplied map is bad");i.set(e,i.get(e)+1);}static isInArray(i,e){for(let t=0;t<i.length;t++)if(i[t]===e)return  true;return  false}static getCounterClockwiseMove(i,e){if(!i.has(e))throw Error("Key not found");let t=[...i.get(e)];if(t.length==1)return e=t[0],e;for(let r=t.length-1;r>=0;r--)this.doesMoveExistElsewhere(i,e,t[r])&&t.splice(r,1);return t[0]}static doesMoveExistElsewhere(i,e,t){if(i.has(e)==false)throw new Error("Could not find node");return this.isInArray(i.get(t),e)}static doesKeyHaveSpecificValue(i,e,t){if(!i.has(e))throw Error("Key not found in hash graph");let r=i.get(e);for(let o=0;o<r.length;o++)if(r[o]===t)return  true;return  false}static findNodeThatHasSpecificNodeAsConnection(i,e,t,r){if(!i.has(e))throw Error("Key not found in hash graph");let o=i.get(e);for(let n=0;n<o.length;n++)if(o[n]!==r&&this.doesKeyHaveSpecificValue(i,o[n],t))return o[n];return  -1}static runSearchMovementAroundCenter(i,e,t,r,o){let n=100,h=1,l=t,p=r,E=e;for(;l!=E;){if(h++,h>n||l==-1)return  false;let k=l;l=this.findNodeThatHasSpecificNodeAsConnection(i,l,p,o),o=k;}return  true}static isNodeSurroundedByNodes(i,e){if(!i.has(e))throw Error("Key not found in hash graph");let t=i.get(e),n=[];for(let h=0;h<t.length;h++){let l=t[h],p=l,E=this.findNodeThatHasSpecificNodeAsConnection(i,l,e,p),k=this.runSearchMovementAroundCenter(i,l,E,e,p);n.push(k);}return this.isInArray(n,true)}static getOutsideNode(i){for(let e of i.keys())if(!this.isNodeSurroundedByNodes(i,e))return e;return  -1}static randomIntBetween(i,e){let t=Math.round(Math.random()*(e-i));return i+t}static multiplyArray(i,e){let t=[];for(let r of i)t.push(r*e);return t}static divideArray(i,e){if(e==0)throw new Error("Divisor is 0, critical failure, cannot divide by zero!");let t=[];for(let r of i)t.push(r/e);return t}static elementWiseMultiplication(i,e){if(i.length!=e.length)throw new Error("Array lengths are different!");let t=[];for(let r=0;r<i.length;r++)t.push(i[r]*e[r]);return t}static randomP5Color(){return "rgb("+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+")"}static getNodesOnOutsideOfCounterClockwiseGraph(i,e){e==null&&(e=15);let t=1;new Map(i);let o=this.getOutsideNode(i),n=this.getCounterClockwiseMove(i,o),h=[];for(;t<e&&n!=o;){t++;let l=this.getCounterClockwiseMove(i,n);h.push(n),n=l;}return h.push(n),h}static addElementsToArray(i,e){for(let t of e)i.push(t);}static removeIndicesFromArray(i,e){i=[...i];let t;for(let r=e.length-1;r>=0;r--)t=e[r],i.splice(t,1);return i}static clampNumber(i,e,t){return i=i>t?t:i,i=i<e?e:i,i}};f.noDuplicates=i=>[...new Set(i)];var x=class i{constructor(e){this.verticeReferences=e;}getVerticeRef(e){return this.verticeReferences[e]}doesUpspaceContain(e,t){let r=a.sub(e.getVertex(t),e.getVertex(this.verticeReferences[0])),o=this.computeNormal(e),n=a.dotProduct(r,o);return !(Math.abs(n)<1e-5||n<0)}computeCentroid(e){let t=e.getVertex(this.verticeReferences[0]),r=e.getVertex(this.verticeReferences[1]),o=e.getVertex(this.verticeReferences[2]),n=a.lerpVector(t,r,.5);return a.lerpVector(n,o,.33333)}static isDotProductLEThanX(e,t,r){throw Error("function has been moved to the vector class.")}computeNormal(e){let t=a.sub(e.getVertex(this.verticeReferences[0]),e.getVertex(this.verticeReferences[1])),r=a.sub(e.getVertex(this.verticeReferences[2]),e.getVertex(this.verticeReferences[0])),o=a.crossProduct(t,r);return a.unitVector(o)}distanceTo(e,t){let r=this.computeNormal(e),o=e.getVertex(this.verticeReferences[0]),n=-(r.x*o.x+r.y*o.y+r.z*o.z);return Math.abs(r.x*t.x+r.y*t.y+r.z*t.z+n)/Math.sqrt(r.x**2+r.y**2+r.z**2)}getFarthestPoint(e,t){if(!(t.length>0))throw Error("pointIndices must contain at least one entry");let r=t[0],o=0;for(let n of t){let h=e.getVertex(n),l=this.distanceTo(e,h);l>o&&(o=l,r=n);}return r}flipNormal(){return new i(this.verticeReferences.reverse())}static addPointsFromTrianglesToMap(e,t){t=[...t];for(let r=0;r<t.length;r++){let o=t[r].verticeReferences;for(let n=0;n<o.length-1;n++)f.addToMap(e,t[r].verticeReferences[n],t[r].verticeReferences[n+1]);f.addToMap(e,t[r].verticeReferences[2],t[r].verticeReferences[0]);}}static createPyramidFromBoundaryPoints(e,t){let r=[];for(let o=0;o<e.length-1;o++){let n=new this([t,e[o],e[o+1]]);r.push(n);}return r.push(new this([t,e[e.length-1],e[0]])),r}copy(){let e=[];for(let t of this.verticeReferences)e.push(t);return new i(e)}};var P,F,A=class{constructor(e,t){u(this,P);u(this,F);c(this,P,e),c(this,F,t);}get p1(){return s(this,P)}get p2(){return s(this,F)}isEqual(e){return this===e||s(this,P)===e.p1&&s(this,F)===e.p2||s(this,P)===e.p2&&s(this,F)==e.p1}distanceToPoint(e){let t=a.sub(e,s(this,P)),r=a.sub(s(this,F),s(this,P));return a.magnitude(a.crossProduct(t,r))/a.magnitude(r)}};P=new WeakMap,F=new WeakMap;var g=class i{constructor(e){this.array=e,e==null&&(this.array=[]);}getVertex(e){return this.array[e]}static generateFieldFromMatrixOfPoints(e){let t=new i([]);for(let r of e)t.array.push(new a(r[0],r[1],r[2]));return t}generateRandomPointsInSphere(e,t){this.array=[];for(let r=0;r<t;r++)this.array.push(a.generateVectorInSphere(e));}getTriangleUpspace(e,t){let r=[];for(let o of t)o==e.getVerticeRef(0)||o==e.getVerticeRef(1)||o==e.getVerticeRef(2)||e.doesUpspaceContain(this,o)&&r.push(o);return r}getTrianglesWithPointInUpspace(e,t){let r=[],o;for(let n=0;n<e.length;n++)o=e[n],o.doesUpspaceContain(this,t)&&r.push(o);return r}getTriangleIndicesWithPointInUpspace(e,t){let r=[],o;for(let n=0;n<e.length;n++)o=e[n],o.doesUpspaceContain(this,t)&&r.push(n);return r}getTrianglesUpspaces(e,t){let r=[];for(let o of e)r.push(this.getTriangleUpspace(o,t));return r=f.combineArrays(r),f.noDuplicates(r)}getPointsAtIndices(e,t){let r=[];for(let o of t)r.push(e.array[o]);return r}getAverageDistanceBetweenPointsAndTriangles(e,t){let r=[];for(let o of t){let n=0;for(let l of e)n+=l.distanceTo(this,this.getVertex(o));let h=n/e.length;r.push(h);}return r}getFarthestPointFromTriangles(e,t){let r=this.getFarthestPointsFromTriangles(e,t),o=this.getAverageDistanceBetweenPointsAndTriangles(e,r),n=f.getIndexOfArrayMax(o);if(n==null)throw Error("Bad error");return r[n]}getFarthestPointsFromTriangles(e,t){let r=[];for(let n of e)r.push(n.getFarthestPoint(this,t));return r}getFarthestVectorFromVector(e){let t=0,o=-1,n=this.array[e];for(let h=0;h<this.array.length;h++){let l=a.distanceBetweenVectors(this.array[h],n);l>t&&(t=l,this.array[h],o=h);}if(o==-1)throw Error("no farthest distance point found at all");return o}calculateLargestTriangleFromField(){let e=this.lowestVectorInField(),t=this.getFarthestVectorFromVector(e),r=new A(this.array[e],this.array[t]),o=this.calculateFarthestPoint(r);return new x([e,t,o])}calculateFarthestPoint(e){let t=0,o=-1;for(let n=0;n<this.array.length;n++){if(a.isVectorEqual(this.array[n],e.p1)||a.isVectorEqual(this.array[n],e.p2))continue;let l=e.distanceToPoint(this.array[n]);t<l&&(this.array[n],t=l,o=n);}if(o==-1)throw Error("no farthest point found");return o}lowestVectorInField(){if(this.array.length==0)throw Error("array length is 0");let e=this.array[0],t=0;for(let r=0;r<this.array.length;r++)e.x>this.array[r].x&&(e=this.array[r],t=r,r=0);return t}findVectorWithLowestZ(){let e=1/0,t=-1;for(let r=0;r<this.array.length;r++){let o=this.array[r];o.z<e&&(e=o.z,t=r);}if(t==-1)throw Error("no vector found!");return t}findVectorWithHighestZ(){let e=-1/0,t=-1;for(let r=0;r<this.array.length;r++){let o=this.array[r];o.z>e&&(e=o.z,t=r);}if(t==-1)throw Error("no vector found!");return t}moveEntireField(e){let t=[];for(let r=0;r<this.array.length;r++)t.push(a.add(this.array[r],e));return new i(t)}copy(){let e=[];for(let t of this.array)e.push(new a(t.x,t.y,t.z));return new i(e)}numPoints(){return this.array.length}};var I,N,ne=class ne{constructor(e,t){u(this,I);u(this,N);c(this,I,e),c(this,N,t);}worldPositionOfDirection(){return a.add(s(this,I),s(this,N))}copy(){return new ne(s(this,I).copy(),s(this,N).copy())}get position(){return s(this,I)}get direction(){return s(this,N)}};I=new WeakMap,N=new WeakMap;var ee=ne;var V,b,se=class se{constructor(e,t){u(this,V);u(this,b);if(!(e instanceof g))throw Error("vertices is not an instance of Field");if(!Array.isArray(t))throw Error("triangles is not an array");c(this,V,e),c(this,b,t),e==null&&c(this,V,new g([])),t==null&&c(this,b,[]);}calculateTriangleNormalVector(e){if(!(e instanceof x))throw Error("triange is not an instance of Triangle");let t=e.computeCentroid(s(this,V)),r=e.computeNormal(s(this,V));return new ee(t,r)}calculateTriangleNormalVectors(){s(this,V);let t=[];for(let r of s(this,b))t.push(this.calculateTriangleNormalVector(r));return t}copy(){let e=[];for(let t of s(this,b))e.push(t.copy());return new se(s(this,V).copy(),e)}numPoints(){return s(this,V).numPoints()}numTriangles(){return s(this,b).length}getVertex(e){if(!Number.isSafeInteger(e))throw Error("index is not a safe integer");return s(this,V).getVertex(e)}getTriangle(e){if(!Number.isSafeInteger(e))throw Error("index is not a safe integer");return s(this,b)[e]}set vertices(e){if(!(e instanceof g))throw Error("vertices must be an instance of Field");c(this,V,e);}set triangles(e){if(!Array.isArray(e))throw Error("triangles is not an array");c(this,b,e);}};V=new WeakMap,b=new WeakMap;var j=se;var S,te,U,ue=class{constructor(e,t,r){u(this,S);u(this,te);u(this,U);c(this,S,e),c(this,U,r),c(this,te,t);}calculateObservedColor(e){let r=s(this,S).multiplyByNumber(s(this,U)).multiplyByNumber(1/255),n=e.multiplyByNumber(1/255).elementWiseMultiplication(r);return n=n.multiplyByNumber(255),n}};S=new WeakMap,te=new WeakMap,U=new WeakMap;var pe=class{static convexHullIterativeProcess(e,t,r){t=[...t];let o=e.getTrianglesUpspaces(t,r),n=o[0];if(o.length==1)n=o[0];else {if(o.length==0)return [];n=e.getFarthestPointFromTriangles(t,o);}if(n===void 0)throw Error("LOOK AT THIS CODE LINE IDK - 12/10/2025 - when i took on the task of converting it all to TS");let h=e.getTriangleIndicesWithPointInUpspace(t,n),l=e.getTrianglesWithPointInUpspace(t,n),p=new Map;x.addPointsFromTrianglesToMap(p,l);let E=f.getNodesOnOutsideOfCounterClockwiseGraph(p,1e3),k=x.createPyramidFromBoundaryPoints(E,n);return t=f.removeIndicesFromArray(t,h),f.addElementsToArray(t,k),t}static generateConvexMesh(e,t){let n;n=[e.calculateLargestTriangleFromField()],n.push(n[0].flipNormal());let h=f.arrayOfIndices(e.numPoints());n=this.convexHullIterativeProcess(e,n,h);for(let l=0;l<t;l++){let p=this.convexHullIterativeProcess(e,n,h);if(p.length==0)return new j(e,n);n=p;}return new j(e,n)}};var w,d,T,v,ae=class ae{constructor(e,t,r,o){u(this,w);u(this,d);u(this,T);u(this,v);c(this,w,e),e instanceof a||c(this,w,new a(0,0,0)),c(this,d,t),t instanceof a||c(this,d,new a(0,0,0)),c(this,T,r),r instanceof a||c(this,T,new a(0,0,0)),c(this,v,o),o==null&&c(this,v,.01);}update(e){c(this,w,a.add(s(this,w),a.scalarMult(s(this,d),e))),c(this,d,a.add(s(this,d),a.scalarMult(s(this,T),e))),c(this,d,a.scalarMult(s(this,d),1-s(this,v)));}get position(){return s(this,w).copy()}get velocity(){return s(this,d).copy()}get acceleration(){return s(this,T).copy()}set position(e){if(!(e instanceof a))throw Error("Position input is not of type Vector");c(this,w,e);}set velocity(e){if(!(e instanceof a))throw Error("Velocity input is not of type Vector");c(this,d,e);}set acceleration(e){if(!(e instanceof a))throw Error("Acceleration input is not of type Vector");c(this,T,e);}copy(){return new ae(s(this,w).copy(),s(this,d).copy(),s(this,T).copy(),s(this,v))}};w=new WeakMap,d=new WeakMap,T=new WeakMap,v=new WeakMap;var me=ae;var M,C,W,D,H,B,K,ce=class ce{constructor(e,t,r,o,n){u(this,M);u(this,C);u(this,W);u(this,D);u(this,H);u(this,B);u(this,K);c(this,M,e),c(this,C,a.unitVector(t)),c(this,W,r),c(this,D,o),c(this,H,n),c(this,B,new a(0,1,0)),c(this,K,a.unitVector(a.crossProduct(s(this,B),t)));}get focalDistance(){return s(this,D)}setPosition(e){if(!(e instanceof a))throw Error("position is not an instance of Vector");s(this,M).position=e;}putCameraAtCenterOfMeshCoordinateSystem(e){let t=e.copy();return t=this.shiftMeshIntoCameraSpace(t),t=this.projectMeshOntoCameraAxis(t),t}shiftMeshIntoCameraSpace(e){let t=[],r=e.copy();for(let o=0;o<e.numPoints();o++)t.push(a.sub(e.getVertex(o),s(this,M).position));return r.vertices=new g(t),r}projectMeshOntoCameraAxis(e){let t=[],r=e.copy();for(let o=0;o<e.numPoints();o++){let n=e.getVertex(o),h=a.dotProduct(n,s(this,K)),l=a.dotProduct(n,s(this,B)),p=a.dotProduct(n,s(this,C));t.push(new a(h,l,p));}return r.vertices=new g(t),r}rejectNegativeZValuesList(e){let t=[];for(let r=0;r<e.numPoints();r++)t.push(this.isVertexVisible(e.getVertex(r)));return t}isVertexVisible(e){return !(e.z<0)}copy(){return new ce(s(this,M).copy(),s(this,C).copy(),s(this,W),s(this,D),s(this,H))}pointAtPoint(e){if(!(e instanceof a))throw Error("point is not an instance of Vector");c(this,C,a.unitVector(a.sub(e,s(this,M).position)));}log(){console.log("start camer log"),console.log(s(this,M).position),console.log(s(this,C)),console.log("end camera log");}};M=new WeakMap,C=new WeakMap,W=new WeakMap,D=new WeakMap,H=new WeakMap,B=new WeakMap,K=new WeakMap;var fe=ce;var re=class{constructor(e){this.acceleration=e;}};var de=class extends re{constructor(e){super(e),this.currentTheta=0;}rotateCameraAroundPointOnXZPlane(e,t,r,o){let n=e.copy(),h=a.add(t,new a(Math.sin(this.currentTheta)*r,0,Math.cos(this.currentTheta)*r));return this.currentTheta+=o,n.setPosition(h),n.pointAtPoint(t),n}};var oe=class{constructor(e,t,r,o){this.mesh=e,this.camera=t,this.lights=r,this.renderParameters=o;}backFaceCulling(e){let t=new a(0,0,1),o=e.copy(),n=[],h=o.calculateTriangleNormalVectors();for(let l=0;l<h.length;l++);for(let l=0;l<this.mesh.numTriangles();l++){let p;this.renderParameters.isPerspective?p=this.mesh.getVertex(this.mesh.getTriangle(l).getVerticeRef(0)).isDotProductLEThanX(h[l].direction,0):p=t.isDotProductLEThanX(h[l].direction,0),p&&n.push(this.mesh.getTriangle(l));}return o.triangles=n,o}};var m,z,ge=class extends oe{constructor(t,r,o,n,h,l){super(t,o,n,h);u(this,m);u(this,z);l.createCanvas(r.x,r.y),c(this,z,l),c(this,m,l.createGraphics(r.x,r.y));}preWork(){s(this,m).clear(),s(this,m).background(140);}postWork(){s(this,z).image(s(this,m),0,0);}graph(){this.preWork();let t=this.mesh.copy();t=this.camera.putCameraAtCenterOfMeshCoordinateSystem(t),console.log(t.getVertex(0)),this.renderParameters.doBackFaceCulling&&(t=this.backFaceCulling(t)),t=this.applyProjection(t),t=this.meshToCanvas(t),this.graphVertices(t),this.graphTriangles(t,s(this,z).color(0)),this.postWork();}orthographicProjectIndividualVector(t){return new a(t.x,t.y,this.camera.focalDistance)}perspectiveProjectIndividualVector(t){let r=this.camera.focalDistance/t.z,o=t.x*r,n=t.y*r,h=this.camera.focalDistance;return new a(o,n,h)}perspectiveProjectNormalVectorIntoLine(t,r){let o=this.perspectiveProjectIndividualVector(t.position),n=this.perspectiveProjectIndividualVector(a.add(a.scalarMult(t.direction,r),t.position));return new A(o,n)}perspectiveProjectNormalVectorsIntoLines(t,r){let o=[];for(let n of t)o.push(this.perspectiveProjectNormalVectorIntoLine(n,r));return o}applyProjection(t){let r=t.copy(),o=[];for(let h=0;h<r.numPoints();h++){let l,p=r.getVertex(h);this.renderParameters.isPerspective?l=this.perspectiveProjectIndividualVector(p):l=this.orthographicProjectIndividualVector(p),o.push(l);}let n=new g(o);return r.vertices=n,r}linesToCanvas(t){let r=[];for(let o of t)r.push(new A(this.calculateCanvasPos(o.p1),this.calculateCanvasPos(o.p2)));return r}meshToCanvas(t){let r=t.copy(),o=[];for(let n=0;n<r.numPoints();n++)o.push(this.calculateCanvasPos(t.getVertex(n)));return t.vertices=new g(o),t}calculateCanvasPos(t){return a.add(new a(s(this,m).width/2,s(this,m).height/2,0),t)}graphVertices(t){for(let r=0;r<t.numPoints();r++)r==0&&console.log(t.getVertex(0)),this.graphVertex(t.getVertex(r),this.renderParameters.pointRadius);}graphVertex(t,r){s(this,m).stroke(0),s(this,m).fill(0),s(this,m).circle(t.x,t.y,r);}graphVisibleVertex(t,r){this.camera.isVertexVisible(t)&&this.graphVertex(t,r);}graphVisibleVertices(t,r){for(let o=0;o<this.mesh.numPoints();o++)this.graphVisibleVertex(t.getVertex(o),r);}graphTriangle(t,r){let o=t.getVertex(r.getVerticeRef(0)),n=t.getVertex(r.getVerticeRef(1)),h=t.getVertex(r.getVerticeRef(2));s(this,m).strokeJoin(s(this,z).ROUND),s(this,m).noFill(),s(this,m).triangle(o.x,o.y,n.x,n.y,h.x,h.y);}graphTriangles(t,r){s(this,m).stroke(r);for(let o=0;o<t.numTriangles();o++)this.graphTriangle(t,t.getTriangle(o));}graphLines(t,r){for(let o of t)this.graphLine(o,r);}graphLine(t,r){this.graphBetweenTwoPoints(t.p1,t.p2,r);}graphBetweenTwoPoints(t,r,o){s(this,m).stroke(o),s(this,m).line(t.x,t.y,r.x,r.y);}copy(){}};m=new WeakMap,z=new WeakMap;var q,X,Z,G,Y,J,Q,$,_,ie=class{constructor(e,t,r,o,n,h,l,p,E){u(this,q);u(this,X);u(this,Z);u(this,G);u(this,Y);u(this,J);u(this,Q);u(this,$);u(this,_);c(this,q,e),c(this,X,t),c(this,Z,r),c(this,G,o),c(this,Y,n),c(this,J,h),c(this,Q,l),c(this,$,p),c(this,_,E);}get doBackFaceCulling(){return s(this,q)}get doOutline(){return s(this,X)}get doFill(){return s(this,Z)}get doVertices(){return s(this,G)}get doNormalVectors(){return s(this,Y)}get doShadingWithLighting(){return s(this,J)}get lineWidth(){return s(this,Q)}get pointRadius(){return s(this,$)}get isPerspective(){return s(this,_)}};q=new WeakMap,X=new WeakMap,Z=new WeakMap,G=new WeakMap,Y=new WeakMap,J=new WeakMap,Q=new WeakMap,$=new WeakMap,_=new WeakMap;var Ve=class extends ie{};exports.Camera=fe;exports.Field=g;exports.Light=ue;exports.Mesh=j;exports.MeshGenerator=pe;exports.PhysicsBody=me;exports.Vector=a;exports.p5CameraMover=de;exports.p5MeshRenderer=ge;exports.p5RenderParameters=Ve;return exports;})({});