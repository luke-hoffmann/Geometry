var geometry=(function(exports){'use strict';var pe=i=>{throw TypeError(i)};var me=(i,e,t)=>e.has(i)||pe("Cannot "+t);var n=(i,e,t)=>(me(i,e,"read from private field"),t?t.call(i):e.get(i)),u=(i,e,t)=>e.has(i)?pe("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(i):e.set(i,t),c=(i,e,t,r)=>(me(i,e,"write to private field"),e.set(i,t),t);var D,B,R,b=class b{constructor(e,t,r){u(this,D);u(this,B);u(this,R);c(this,D,e),c(this,B,t),c(this,R,r);}get x(){return n(this,D)}get y(){return n(this,B)}get z(){return n(this,R)}static zero(){return new this(0,0,0)}static isVectorEqual(e,t){if(!(e instanceof b))throw Error("v1 must be a vector");if(!(t instanceof b))throw Error("v2 must be a vector");return e.x===t.x&&e.y===t.y&&t.z===t.z}static unitVector(e){if(!(e instanceof b))throw Error("v must be a vector");let t=e.magnitude();return new this(e.x/t,e.y/t,e.z/t)}static upVector(){return new this(0,0,1)}static generateVectorInSphere(e){e=Math.random()*e*e*e,e=Math.cbrt(e);let t=2,r=0,o=0,s=0;for(;t>1;)r=Math.random()*2-1,o=Math.random()*2-1,s=Math.random()*2-1,t=r*r+o*o+s*s;return new b(r*e,o*e,s*e)}static magnitude(e){if(!(e instanceof b))throw Error("p1 must be a vector");return e.magnitude()}magnitude(){return Math.hypot(this.x,this.y,this.z)}static distanceBetweenVectors(e,t){if(!(e instanceof b))throw Error("v1 must be a vector");if(!(t instanceof b))throw Error("v2 must be a vector");return Math.hypot(e.x-t.x,e.y-t.y,e.z-t.z)}static lerp(e,t,r){if(!Number.isFinite(e))throw Error("p1 is not a finite number");if(!Number.isFinite(t))throw Error("p2 is not a finite number");if(!Number.isFinite(r))throw Error("t is not a finite number");return (t-e)*r+e}static lerpVector(e,t,r){return new this(this.lerp(e.x,t.x,r),this.lerp(e.y,t.y,r),this.lerp(e.z,t.z,r))}static normalize(e){throw Error("depreciated : use Vector.unitVector(v) instead")}static crossProduct(e,t){return new this(e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x)}static dotProduct(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}static sub(e,t){return new this(e.x-t.x,e.y-t.y,e.z-t.z)}static add(e,t){return new this(e.x+t.x,e.y+t.y,e.z+t.z)}static scalarMult(e,t){return new this(e.x*t,e.y*t,e.z*t)}static rotateVector(e,t,r,o){return e=this.rotateAroundX(e,t),e=this.rotateAroundY(e,r),e=this.rotateAroundZ(e,o),e}static rotateAroundX(e,t){return new this(e.x,e.y*Math.cos(t)-e.z*Math.sin(t),e.y*Math.sin(t)+e.z*Math.cos(t))}static rotateAroundY(e,t){return new this(e.x*Math.cos(t)+e.z*Math.sin(t),e.y,-e.x*Math.sin(t)+e.z*Math.cos(t))}static rotateAroundZ(e,t){return new this(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t),e.z)}static rotate2DVector(e,t){return new this(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t),0)}isDotProductLEThanX(e,t){return b.dotProduct(this,e)<=t}copy(){return new b(n(this,D),n(this,B),n(this,R))}};D=new WeakMap,B=new WeakMap,R=new WeakMap;var a=b;var g=class{static getIndexOfArrayMax(i){if(!Array.isArray(i))throw Error("arrayOfNumbers is not an array");if(i.length==0)throw Error("arrayOfNumbers contains no elements");let e=0,t=i[0];for(let r=0;r<i.length;r++){let o=i[r];o>t&&(t=o,e=r);}return e}static isMixedUpArraysEqual(i,e){if(i.length!==e.length)return  false;i=[...i],e=[...e];for(let t=i.length-1;t>=0;t--)for(let r=e.length-1;r>=0;r--)i[t]===e[r]&&(i.splice(t,1),e.splice(r,1));return i.length==0&&e.length==0}static isThereValueGreaterThanN(i,e){for(let t of i)if(t>e)return  true;return  false}static combineArrays(i){let e=[];for(let t of i)for(let r of t)e.push(r);return e}static arrayOfIndices(i){let e=[];for(let t=0;t<i;t++)e.push(t);return e}static addToMap(i,e,t){i.has(e)||i.set(e,[]);i.get(e).push(t);return i}static incrementMap(i,e){if(!i.has(e))throw new Error("Supplied map is bad");i.set(e,i.get(e)+1);}static isInArray(i,e){for(let t=0;t<i.length;t++)if(i[t]===e)return  true;return  false}static getCounterClockwiseMove(i,e){if(!i.has(e))throw Error("Key not found");let t=[...i.get(e)];if(t.length==1)return e=t[0],e;for(let r=t.length-1;r>=0;r--)this.doesMoveExistElsewhere(i,e,t[r])&&t.splice(r,1);return t[0]}static doesMoveExistElsewhere(i,e,t){if(i.has(e)==false)throw new Error("Could not find node");return this.isInArray(i.get(t),e)}static doesKeyHaveSpecificValue(i,e,t){if(!i.has(e))throw Error("Key not found in hash graph");let r=i.get(e);for(let o=0;o<r.length;o++)if(r[o]===t)return  true;return  false}static findNodeThatHasSpecificNodeAsConnection(i,e,t,r){if(!i.has(e))throw Error("Key not found in hash graph");let o=i.get(e);for(let s=0;s<o.length;s++)if(o[s]!==r&&this.doesKeyHaveSpecificValue(i,o[s],t))return o[s];return  -1}static runSearchMovementAroundCenter(i,e,t,r,o){let s=100,h=1,l=t,p=r,E=e;for(;l!=E;){if(h++,h>s||l==-1)return  false;let N=l;l=this.findNodeThatHasSpecificNodeAsConnection(i,l,p,o),o=N;}return  true}static isNodeSurroundedByNodes(i,e){if(!i.has(e))throw Error("Key not found in hash graph");let t=i.get(e),s=[];for(let h=0;h<t.length;h++){let l=t[h],p=l,E=this.findNodeThatHasSpecificNodeAsConnection(i,l,e,p),N=this.runSearchMovementAroundCenter(i,l,E,e,p);s.push(N);}return this.isInArray(s,true)}static getOutsideNode(i){for(let e of i.keys())if(!this.isNodeSurroundedByNodes(i,e))return e;return  -1}static randomIntBetween(i,e){let t=Math.round(Math.random()*(e-i));return i+t}static multiplyArray(i,e){let t=[];for(let r of i)t.push(r*e);return t}static divideArray(i,e){if(e==0)throw new Error("Divisor is 0, critical failure, cannot divide by zero!");let t=[];for(let r of i)t.push(r/e);return t}static elementWiseMultiplication(i,e){if(i.length!=e.length)throw new Error("Array lengths are different!");let t=[];for(let r=0;r<i.length;r++)t.push(i[r]*e[r]);return t}static randomP5Color(){return "rgb("+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+")"}static getNodesOnOutsideOfCounterClockwiseGraph(i,e){e==null&&(e=15);let t=1;new Map(i);let o=this.getOutsideNode(i),s=this.getCounterClockwiseMove(i,o),h=[];for(;t<e&&s!=o;){t++;let l=this.getCounterClockwiseMove(i,s);h.push(s),s=l;}return h.push(s),h}static addNumbersToNumberArray(i,e){let t=[...i];for(let r of e)t.push(r);return t}static removeIndicesFromArray(i,e){i=[...i];let t;for(let r=e.length-1;r>=0;r--)t=e[r],i.splice(t,1);return i}static clampNumber(i,e,t){return i=i>t?t:i,i=i<e?e:i,i}};g.noDuplicates=i=>[...new Set(i)];var m,re=class re{constructor(e){u(this,m);c(this,m,e);}logReferences(){console.log(n(this,m)[0],n(this,m)[1],n(this,m)[2]);}doesUpspaceContain(e,t){let r=a.sub(e.getVertex(t),e.getVertex(n(this,m)[0])),o=this.computeNormal(e),s=a.dotProduct(r,o);return !(Math.abs(s)<1e-5||s<0)}computeCentroid(e){let t=e.getVertex(n(this,m)[0]),r=e.getVertex(n(this,m)[1]),o=e.getVertex(n(this,m)[2]),s=a.lerpVector(t,r,.5);return a.lerpVector(s,o,.33333)}static isDotProductLEThanX(e,t,r){throw Error("function has been moved to the vector class.")}computeNormal(e){let t=a.sub(e.getVertex(n(this,m)[0]),e.getVertex(n(this,m)[1])),r=a.sub(e.getVertex(n(this,m)[2]),e.getVertex(n(this,m)[0])),o=a.crossProduct(t,r);return a.unitVector(o)}distanceTo(e,t){let r=this.computeNormal(e),o=e.getVertex(n(this,m)[0]),s=-(r.x*o.x+r.y*o.y+r.z*o.z);return Math.abs(r.x*t.x+r.y*t.y+r.z*t.z+s)/Math.sqrt(r.x**2+r.y**2+r.z**2)}getFarthestPoint(e,t){if(!(t.length>0))throw Error("pointIndices must contain at least one entry");let r=t[0],o=0;for(let s of t){let h=e.getVertex(s),l=this.distanceTo(e,h);l>o&&(o=l,r=s);}return r}flipNormal(){return new re([n(this,m)[2],n(this,m)[1],n(this,m)[0]])}getVerticeReference(e){return n(this,m)[e]}static addPointsFromTrianglesToMap(e,t){for(let r=0;r<t.length;r++){for(let o=0;o<2;o++)g.addToMap(e,t[r].getVerticeReference(o),t[r].getVerticeReference(o+1));g.addToMap(e,t[r].getVerticeReference(2),t[r].getVerticeReference(0));}}static createPyramidFromBoundaryPoints(e,t){let r=[];for(let o=0;o<e.length-1;o++){let s=new this([t,e[o],e[o+1]]);r.push(s);}return r.push(new this([t,e[e.length-1],e[0]])),r}copy(){let e=[];for(let t of n(this,m))e.push(t);return new re(e)}};m=new WeakMap;var T=re;var P,C,I=class{constructor(e,t){u(this,P);u(this,C);c(this,P,e),c(this,C,t);}get p1(){return n(this,P)}get p2(){return n(this,C)}isEqual(e){return this===e||n(this,P)===e.p1&&n(this,C)===e.p2||n(this,P)===e.p2&&n(this,C)==e.p1}distanceToPoint(e){let t=a.sub(e,n(this,P)),r=a.sub(n(this,C),n(this,P));return a.magnitude(a.crossProduct(t,r))/a.magnitude(r)}};P=new WeakMap,C=new WeakMap;var V=class i{constructor(e){this.array=e,e==null&&(this.array=[]);}getVertex(e){return this.array[e]}static generateFieldFromMatrixOfPoints(e){let t=new i([]);for(let r of e)t.array.push(new a(r[0],r[1],r[2]));return t}generateRandomPointsInSphere(e,t){this.array=[];for(let r=0;r<t;r++)this.array.push(a.generateVectorInSphere(e));}getTriangleUpspace(e,t){let r=[];for(let o of t)o==e.getVerticeReference(0)||o==e.getVerticeReference(1)||o==e.getVerticeReference(2)||e.doesUpspaceContain(this,o)&&r.push(o);return r}getTrianglesWithPointInUpspace(e,t){let r=[],o;for(let s=0;s<e.length;s++)o=e[s],o.doesUpspaceContain(this,t)&&r.push(o);return r}getTriangleIndicesWithPointInUpspace(e,t){let r=[],o;for(let s=0;s<e.length;s++)o=e[s],o.doesUpspaceContain(this,t)&&r.push(s);return r}getTrianglesUpspaces(e,t){let r=[];for(let o of e)r.push(this.getTriangleUpspace(o,t));return r=g.combineArrays(r),g.noDuplicates(r)}getPointsAtIndices(e,t){let r=[];for(let o of t)r.push(e.array[o]);return r}getAverageDistanceBetweenPointsAndTriangles(e,t){let r=[];for(let o of t){let s=0;for(let l of e)s+=l.distanceTo(this,this.getVertex(o));let h=s/e.length;r.push(h);}return r}getFarthestPointFromTriangles(e,t){let r=this.getFarthestPointsFromTriangles(e,t),o=this.getAverageDistanceBetweenPointsAndTriangles(e,r),s=g.getIndexOfArrayMax(o);if(s==null)throw Error("Bad error");return r[s]}getFarthestPointsFromTriangles(e,t){let r=[];for(let s of e)r.push(s.getFarthestPoint(this,t));return r}getFarthestVectorFromVector(e){let t=0,o=-1,s=this.array[e];for(let h=0;h<this.array.length;h++){let l=a.distanceBetweenVectors(this.array[h],s);l>t&&(t=l,this.array[h],o=h);}if(o==-1)throw Error("no farthest distance point found at all");return o}calculateLargestTriangleFromField(){let e=this.lowestVectorInField(),t=this.getFarthestVectorFromVector(e),r=new I(this.array[e],this.array[t]),o=this.calculateFarthestPoint(r);return new T([e,t,o])}calculateFarthestPoint(e){let t=0,o=-1;for(let s=0;s<this.array.length;s++){if(a.isVectorEqual(this.array[s],e.p1)||a.isVectorEqual(this.array[s],e.p2))continue;let l=e.distanceToPoint(this.array[s]);t<l&&(this.array[s],t=l,o=s);}if(o==-1)throw Error("no farthest point found");return o}lowestVectorInField(){if(this.array.length==0)throw Error("array length is 0");let e=this.array[0],t=0;for(let r=0;r<this.array.length;r++)e.x>this.array[r].x&&(e=this.array[r],t=r,r=0);return t}findVectorWithLowestZ(){let e=1/0,t=-1;for(let r=0;r<this.array.length;r++){let o=this.array[r];o.z<e&&(e=o.z,t=r);}if(t==-1)throw Error("no vector found!");return t}findVectorWithHighestZ(){let e=-1/0,t=-1;for(let r=0;r<this.array.length;r++){let o=this.array[r];o.z>e&&(e=o.z,t=r);}if(t==-1)throw Error("no vector found!");return t}moveEntireField(e){let t=[];for(let r=0;r<this.array.length;r++)t.push(a.add(this.array[r],e));return new i(t)}copy(){let e=[];for(let t of this.array)e.push(new a(t.x,t.y,t.z));return new i(e)}numPoints(){return this.array.length}};var z,L,ce=class ce{constructor(e,t){u(this,z);u(this,L);c(this,z,e),c(this,L,t);}worldPositionOfDirection(){return a.add(n(this,z),n(this,L))}copy(){return new ce(n(this,z).copy(),n(this,L).copy())}get position(){return n(this,z)}get direction(){return n(this,L)}};z=new WeakMap,L=new WeakMap;var oe=ce;var y,w,le=class le{constructor(e,t){u(this,y);u(this,w);if(!(e instanceof V))throw Error("vertices is not an instance of Field");if(!Array.isArray(t))throw Error("triangles is not an array");c(this,y,e),c(this,w,t),e==null&&c(this,y,new V([])),t==null&&c(this,w,[]);}calculateTriangleNormalVector(e){if(!(e instanceof T))throw Error("triange is not an instance of Triangle");let t=e.computeCentroid(n(this,y)),r=e.computeNormal(n(this,y));return new oe(t,r)}calculateTriangleNormalVectors(){n(this,y);let t=[];for(let r of n(this,w))t.push(this.calculateTriangleNormalVector(r));return t}copy(){let e=[];for(let t of n(this,w))e.push(t.copy());return new le(n(this,y).copy(),e)}numPoints(){return n(this,y).numPoints()}numTriangles(){return n(this,w).length}getVertex(e){if(!Number.isSafeInteger(e))throw Error("index is not a safe integer");return n(this,y).getVertex(e)}getTriangle(e){if(!Number.isSafeInteger(e))throw Error("index is not a safe integer");return n(this,w)[e]}set vertices(e){if(!(e instanceof V))throw Error("vertices must be an instance of Field");c(this,y,e);}set triangles(e){if(!Array.isArray(e))throw Error("triangles is not an array");c(this,w,e);}};y=new WeakMap,w=new WeakMap;var S=le;var U,ie,W,fe=class{constructor(e,t,r){u(this,U);u(this,ie);u(this,W);c(this,U,e),c(this,W,r),c(this,ie,t);}calculateObservedColor(e){let r=n(this,U).multiplyByNumber(n(this,W)).multiplyByNumber(1/255),s=e.multiplyByNumber(1/255).elementWiseMultiplication(r);return s=s.multiplyByNumber(255),s}};U=new WeakMap,ie=new WeakMap,W=new WeakMap;var de=class i{static convexHullIterativeProcess(e,t,r){t=[...t];let o=e.getTrianglesUpspaces(t,r),s=o[0];if(o.length==1)s=o[0];else {if(o.length==0)return [];s=e.getFarthestPointFromTriangles(t,o);}if(s===void 0)throw Error("LOOK AT THIS CODE LINE IDK - 12/10/2025 - when i took on the task of converting it all to TS");let h=e.getTriangleIndicesWithPointInUpspace(t,s),l=e.getTrianglesWithPointInUpspace(t,s),p=new Map;T.addPointsFromTrianglesToMap(p,l);let E=g.getNodesOnOutsideOfCounterClockwiseGraph(p,1e5),N=T.createPyramidFromBoundaryPoints(E,s);return t=g.removeIndicesFromArray(t,h),t=i.addTrianglesToTrianglesArray(t,N),t}static addTrianglesToTrianglesArray(e,t){let r=[];e.forEach(o=>{r.push(o.copy());});for(let o of t)r.push(o);return r}static generateConvexMesh(e,t){let s;s=[e.calculateLargestTriangleFromField()],s.push(s[0].flipNormal());let h=g.arrayOfIndices(e.numPoints());s=this.convexHullIterativeProcess(e,s,h);for(let l=0;l<t;l++){let p=this.convexHullIterativeProcess(e,s,h);if(p.length==0)return new S(e,s);s=p;}return new S(e,s)}};var x,d,M,O,he=class he{constructor(e,t,r,o){u(this,x);u(this,d);u(this,M);u(this,O);c(this,x,e),e instanceof a||c(this,x,new a(0,0,0)),c(this,d,t),t instanceof a||c(this,d,new a(0,0,0)),c(this,M,r),r instanceof a||c(this,M,new a(0,0,0)),c(this,O,o),o==null&&c(this,O,.01);}update(e){c(this,x,a.add(n(this,x),a.scalarMult(n(this,d),e))),c(this,d,a.add(n(this,d),a.scalarMult(n(this,M),e))),c(this,d,a.scalarMult(n(this,d),1-n(this,O)));}get position(){return n(this,x).copy()}get velocity(){return n(this,d).copy()}get acceleration(){return n(this,M).copy()}set position(e){if(!(e instanceof a))throw Error("Position input is not of type Vector");c(this,x,e);}set velocity(e){if(!(e instanceof a))throw Error("Velocity input is not of type Vector");c(this,d,e);}set acceleration(e){if(!(e instanceof a))throw Error("Acceleration input is not of type Vector");c(this,M,e);}copy(){return new he(n(this,x).copy(),n(this,d).copy(),n(this,M).copy(),n(this,O))}};x=new WeakMap,d=new WeakMap,M=new WeakMap,O=new WeakMap;var ge=he;var F,A,H,k,K,j,q,ue=class ue{constructor(e,t,r,o,s){u(this,F);u(this,A);u(this,H);u(this,k);u(this,K);u(this,j);u(this,q);c(this,F,e),c(this,A,a.unitVector(t)),c(this,H,r),c(this,k,o),c(this,K,s),c(this,j,new a(0,1,0)),c(this,q,a.unitVector(a.crossProduct(n(this,j),t)));}get focalDistance(){return n(this,k)}setPosition(e){if(!(e instanceof a))throw Error("position is not an instance of Vector");n(this,F).position=e;}putCameraAtCenterOfMeshCoordinateSystem(e){let t=e.copy();return t=this.shiftMeshIntoCameraSpace(t),t=this.projectMeshOntoCameraAxis(t),t}shiftMeshIntoCameraSpace(e){let t=[],r=e.copy();for(let o=0;o<e.numPoints();o++)t.push(a.sub(e.getVertex(o),n(this,F).position));return r.vertices=new V(t),r}projectMeshOntoCameraAxis(e){let t=[],r=e.copy();for(let o=0;o<e.numPoints();o++){let s=e.getVertex(o),h=a.dotProduct(s,n(this,q)),l=a.dotProduct(s,n(this,j)),p=a.dotProduct(s,n(this,A));t.push(new a(h,l,p));}return r.vertices=new V(t),r}rejectNegativeZValuesList(e){let t=[];for(let r=0;r<e.numPoints();r++)t.push(this.isVertexVisible(e.getVertex(r)));return t}isVertexVisible(e){return !(e.z<0)}copy(){return new ue(n(this,F).copy(),n(this,A).copy(),n(this,H),n(this,k),n(this,K))}pointAtPoint(e){if(!(e instanceof a))throw Error("point is not an instance of Vector");c(this,A,a.unitVector(a.sub(e,n(this,F).position)));}log(){console.log("start camer log"),console.log(n(this,F).position),console.log(n(this,A)),console.log("end camera log");}};F=new WeakMap,A=new WeakMap,H=new WeakMap,k=new WeakMap,K=new WeakMap,j=new WeakMap,q=new WeakMap;var Ve=ue;var ne=class{constructor(e){this.acceleration=e;}};var ye=class extends ne{constructor(e){super(e),this.currentTheta=0;}rotateCameraAroundPointOnXZPlane(e,t,r,o){let s=e.copy(),h=a.add(t,new a(Math.sin(this.currentTheta)*r,0,Math.cos(this.currentTheta)*r));return this.currentTheta+=o,s.setPosition(h),s.pointAtPoint(t),s}};var se=class{constructor(e,t,r,o){this.mesh=e,this.camera=t,this.lights=r,this.renderParameters=o;}backFaceCulling(e){let t=new a(0,0,1),o=e.copy(),s=[],h=o.calculateTriangleNormalVectors();for(let l=0;l<h.length;l++);for(let l=0;l<this.mesh.numTriangles();l++){let p;this.renderParameters.isPerspective?p=this.mesh.getVertex(this.mesh.getTriangle(l).getVerticeReference(0)).isDotProductLEThanX(h[l].direction,0):p=t.isDotProductLEThanX(h[l].direction,0),p&&s.push(this.mesh.getTriangle(l));}return o.triangles=s,o}};var f,v,be=class extends se{constructor(t,r,o,s,h,l){super(t,o,s,h);u(this,f);u(this,v);l.createCanvas(r.x,r.y),c(this,v,l),c(this,f,l.createGraphics(r.x,r.y));}preWork(){n(this,f).clear(),n(this,f).background(140);}postWork(){n(this,v).image(n(this,f),0,0);}graph(){this.preWork();let t=this.mesh.copy();t=this.camera.putCameraAtCenterOfMeshCoordinateSystem(t),this.renderParameters.doBackFaceCulling&&(t=this.backFaceCulling(t)),t=this.applyProjection(t),t=this.meshToCanvas(t),this.renderParameters.doVertices&&this.graphVertices(t),this.renderParameters.doTriangles&&this.graphTriangles(t,n(this,v).color(0)),this.postWork();}orthographicProjectIndividualVector(t){return new a(t.x,t.y,this.camera.focalDistance)}perspectiveProjectIndividualVector(t){let r=this.camera.focalDistance/t.z,o=t.x*r,s=t.y*r,h=this.camera.focalDistance;return new a(o,s,h)}perspectiveProjectNormalVectorIntoLine(t,r){let o=this.perspectiveProjectIndividualVector(t.position),s=this.perspectiveProjectIndividualVector(a.add(a.scalarMult(t.direction,r),t.position));return new I(o,s)}perspectiveProjectNormalVectorsIntoLines(t,r){let o=[];for(let s of t)o.push(this.perspectiveProjectNormalVectorIntoLine(s,r));return o}applyProjection(t){let r=t.copy(),o=[];for(let h=0;h<r.numPoints();h++){let l,p=r.getVertex(h);this.renderParameters.isPerspective?l=this.perspectiveProjectIndividualVector(p):l=this.orthographicProjectIndividualVector(p),o.push(l);}let s=new V(o);return r.vertices=s,r}linesToCanvas(t){let r=[];for(let o of t)r.push(new I(this.calculateCanvasPos(o.p1),this.calculateCanvasPos(o.p2)));return r}meshToCanvas(t){let r=t.copy(),o=[];for(let s=0;s<r.numPoints();s++)o.push(this.calculateCanvasPos(t.getVertex(s)));return t.vertices=new V(o),t}calculateCanvasPos(t){return a.add(new a(n(this,f).width/2,n(this,f).height/2,0),t)}graphVertices(t){for(let r=0;r<t.numPoints();r++)this.graphVertex(t.getVertex(r),3);}graphVertex(t,r){n(this,f).stroke(0),n(this,f).fill(0),n(this,f).circle(t.x,t.y,r);}graphVisibleVertex(t,r){this.camera.isVertexVisible(t)&&this.graphVertex(t,r);}graphVisibleVertices(t,r){for(let o=0;o<this.mesh.numPoints();o++)this.graphVisibleVertex(t.getVertex(o),r);}graphTriangle(t,r){let o=t.getVertex(r.getVerticeReference(0)),s=t.getVertex(r.getVerticeReference(1)),h=t.getVertex(r.getVerticeReference(2));n(this,f).strokeJoin(n(this,v).ROUND),n(this,f).noFill(),n(this,f).triangle(o.x,o.y,s.x,s.y,h.x,h.y);}graphTriangles(t,r){n(this,f).stroke(r);for(let o=0;o<t.numTriangles();o++)this.graphTriangle(t,t.getTriangle(o));}graphLines(t,r){for(let o of t)this.graphLine(o,r);}graphLine(t,r){this.graphBetweenTwoPoints(t.p1,t.p2,r);}graphBetweenTwoPoints(t,r,o){n(this,f).stroke(o),n(this,f).line(t.x,t.y,r.x,r.y);}copy(){}};f=new WeakMap,v=new WeakMap;var X,Z,G,Y,J,Q,$,_,ee,te,ae=class{constructor(e,t,r,o,s,h,l,p,E,N){u(this,X);u(this,Z);u(this,G);u(this,Y);u(this,J);u(this,Q);u(this,$);u(this,_);u(this,ee);u(this,te);c(this,X,e),c(this,Z,t),c(this,G,r),c(this,Y,o),c(this,J,h),c(this,Q,l),c(this,$,p),c(this,_,E),c(this,ee,N),c(this,te,s);}get doBackFaceCulling(){return n(this,X)}get doOutline(){return n(this,Z)}get doFill(){return n(this,G)}get doVertices(){return n(this,Y)}get doTriangles(){return n(this,te)}get doNormalVectors(){return n(this,J)}get doShadingWithLighting(){return n(this,Q)}get lineWidth(){return n(this,$)}get pointRadius(){return n(this,_)}get isPerspective(){return n(this,ee)}};X=new WeakMap,Z=new WeakMap,G=new WeakMap,Y=new WeakMap,J=new WeakMap,Q=new WeakMap,$=new WeakMap,_=new WeakMap,ee=new WeakMap,te=new WeakMap;var we=class extends ae{};exports.Camera=Ve;exports.Field=V;exports.Light=fe;exports.Mesh=S;exports.MeshGenerator=de;exports.PhysicsBody=ge;exports.Vector=a;exports.p5CameraMover=ye;exports.p5MeshRenderer=be;exports.p5RenderParameters=we;return exports;})({});