var geometry=(function(exports){'use strict';var s=class i{#e;#t;#r;constructor(e,t,r){this.#e=e,this.#t=t,this.#r=r;}get x(){return this.#e}get y(){return this.#t}get z(){return this.#r}static zero(){return new this(0,0,0)}static isVectorEqual(e,t){if(!(e instanceof i))throw Error("v1 must be a vector");if(!(t instanceof i))throw Error("v2 must be a vector");return e.x===t.x&&e.y===t.y&&t.z===t.z}static unitVector(e){if(!(e instanceof i))throw Error("v must be a vector");let t=e.magnitude();return new this(e.x/t,e.y/t,e.z/t)}static upVector(){return new this(0,0,1)}static generateVectorInSphere(e){e=Math.random()*e*e*e,e=Math.cbrt(e);let t=2,r=0,o=0,n=0;for(;t>1;)r=Math.random()*2-1,o=Math.random()*2-1,n=Math.random()*2-1,t=r*r+o*o+n*n;return new i(r*e,o*e,n*e)}static magnitude(e){if(!(e instanceof i))throw Error("p1 must be a vector");return e.magnitude()}magnitude(){return Math.hypot(this.x,this.y,this.z)}static distanceBetweenVectors(e,t){if(!(e instanceof i))throw Error("v1 must be a vector");if(!(t instanceof i))throw Error("v2 must be a vector");return Math.hypot(e.x-t.x,e.y-t.y,e.z-t.z)}static lerp(e,t,r){if(!Number.isFinite(e))throw Error("p1 is not a finite number");if(!Number.isFinite(t))throw Error("p2 is not a finite number");if(!Number.isFinite(r))throw Error("t is not a finite number");return (t-e)*r+e}static lerpVector(e,t,r){return new this(this.lerp(e.x,t.x,r),this.lerp(e.y,t.y,r),this.lerp(e.z,t.z,r))}static normalize(e){throw Error("depreciated : use Vector.unitVector(v) instead")}static crossProduct(e,t){return new this(e.y*t.z-e.z*t.y,e.z*t.x-e.x*t.z,e.x*t.y-e.y*t.x)}static dotProduct(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}static sub(e,t){return new this(e.x-t.x,e.y-t.y,e.z-t.z)}static add(e,t){return new this(e.x+t.x,e.y+t.y,e.z+t.z)}static scalarMult(e,t){return new this(e.x*t,e.y*t,e.z*t)}static rotateVector(e,t,r,o){return e=this.rotateAroundX(e,t),e=this.rotateAroundY(e,r),e=this.rotateAroundZ(e,o),e}static rotateAroundX(e,t){return new this(e.x,e.y*Math.cos(t)-e.z*Math.sin(t),e.y*Math.sin(t)+e.z*Math.cos(t))}static rotateAroundY(e,t){return new this(e.x*Math.cos(t)+e.z*Math.sin(t),e.y,-e.x*Math.sin(t)+e.z*Math.cos(t))}static rotateAroundZ(e,t){return new this(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t),e.z)}static rotate2DVector(e,t){return new this(e.x*Math.cos(t)-e.y*Math.sin(t),e.x*Math.sin(t)+e.y*Math.cos(t),0)}isDotProductLEThanX(e,t){return i.dotProduct(this,e)<=t}copy(){return new i(this.#e,this.#t,this.#r)}};var p=class{static getIndexOfArrayMax(i){if(!Array.isArray(i))throw Error("arrayOfNumbers is not an array");if(i.length==0)throw Error("arrayOfNumbers contains no elements");let e=0,t=i[0];for(let r=0;r<i.length;r++){let o=i[r];o>t&&(t=o,e=r);}return e}static isMixedUpArraysEqual(i,e){if(i.length!==e.length)return  false;i=[...i],e=[...e];for(let t=i.length-1;t>=0;t--)for(let r=e.length-1;r>=0;r--)i[t]===e[r]&&(i.splice(t,1),e.splice(r,1));return i.length==0&&e.length==0}static isThereValueGreaterThanN(i,e){for(let t of i)if(t>e)return  true;return  false}static combineArrays(i){let e=[];for(let t of i)for(let r of t)e.push(r);return e}static arrayOfIndices(i){let e=[];for(let t=0;t<i;t++)e.push(t);return e}static addToMap(i,e,t){i.has(e)||i.set(e,[]);i.get(e).push(t);return i}static incrementMap(i,e){if(!i.has(e))throw new Error("Supplied map is bad");i.set(e,i.get(e)+1);}static isInArray(i,e){for(let t=0;t<i.length;t++)if(i[t]===e)return  true;return  false}static getCounterClockwiseMove(i,e){if(!i.has(e))throw Error("Key not found");let t=[...i.get(e)];if(t.length==1)return e=t[0],e;for(let r=t.length-1;r>=0;r--)this.doesMoveExistElsewhere(i,e,t[r])&&t.splice(r,1);return t[0]}static doesMoveExistElsewhere(i,e,t){if(i.has(e)==false)throw new Error("Could not find node");return this.isInArray(i.get(t),e)}static doesKeyHaveSpecificValue(i,e,t){if(!i.has(e))throw Error("Key not found in hash graph");let r=i.get(e);for(let o=0;o<r.length;o++)if(r[o]===t)return  true;return  false}static findNodeThatHasSpecificNodeAsConnection(i,e,t,r){if(!i.has(e))throw Error("Key not found in hash graph");let o=i.get(e);for(let n=0;n<o.length;n++)if(o[n]!==r&&this.doesKeyHaveSpecificValue(i,o[n],t))return o[n];return  -1}static runSearchMovementAroundCenter(i,e,t,r,o){let n=100,a=1,c=t,l=r,h=e;for(;c!=h;){if(a++,a>n||c==-1)return  false;let u=c;c=this.findNodeThatHasSpecificNodeAsConnection(i,c,l,o),o=u;}return  true}static isNodeSurroundedByNodes(i,e){if(!i.has(e))throw Error("Key not found in hash graph");let t=i.get(e),n=[];for(let a=0;a<t.length;a++){let c=t[a],l=c,h=this.findNodeThatHasSpecificNodeAsConnection(i,c,e,l),u=this.runSearchMovementAroundCenter(i,c,h,e,l);n.push(u);}return this.isInArray(n,true)}static getOutsideNode(i){for(let e of i.keys())if(!this.isNodeSurroundedByNodes(i,e))return e;return  -1}static randomIntBetween(i,e){let t=Math.round(Math.random()*(e-i));return i+t}static multiplyArray(i,e){let t=[];for(let r of i)t.push(r*e);return t}static divideArray(i,e){if(e==0)throw new Error("Divisor is 0, critical failure, cannot divide by zero!");let t=[];for(let r of i)t.push(r/e);return t}static elementWiseMultiplication(i,e){if(i.length!=e.length)throw new Error("Array lengths are different!");let t=[];for(let r=0;r<i.length;r++)t.push(i[r]*e[r]);return t}static randomP5Color(){return "rgb("+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+","+Math.round(Math.random()*255)+")"}static getNodesOnOutsideOfCounterClockwiseGraph(i,e){e==null&&(e=15);let t=1;new Map(i);let o=this.getOutsideNode(i),n=this.getCounterClockwiseMove(i,o),a=[];for(;t<e&&n!=o;){t++;let c=this.getCounterClockwiseMove(i,n);a.push(n),n=c;}return a.push(n),a}static removeIndicesFromArray(i,e){i=[...i];let t;for(let r=e.length-1;r>=0;r--)t=e[r],i.splice(t,1);return i}static clampNumber(i,e,t){return i=i>t?t:i,i=i<e?e:i,i}static assertBool(i,e){if(typeof i!="boolean")throw new TypeError(e)}static assertNum(i,e){if(typeof i!="number"||Number.isNaN(i))throw new TypeError(e)}};p.noDuplicates=i=>[...new Set(i)];var f=class i{#e;constructor(e){this.#e=e;}logReferences(){console.log(this.#e[0],this.#e[1],this.#e[2]);}doesUpspaceContain(e,t){let r=s.sub(e.getVertex(t),e.getVertex(this.#e[0])),o=this.computeNormal(e),n=s.dotProduct(r,o);return !(Math.abs(n)<1e-5||n<0)}computeCentroid(e){let t=e.getVertex(this.#e[0]),r=e.getVertex(this.#e[1]),o=e.getVertex(this.#e[2]),n=s.lerpVector(t,r,.5);return s.lerpVector(n,o,.33333)}static isDotProductLEThanX(e,t,r){throw Error("function has been moved to the vector class.")}computeNormal(e){let t=s.sub(e.getVertex(this.#e[0]),e.getVertex(this.#e[1])),r=s.sub(e.getVertex(this.#e[2]),e.getVertex(this.#e[0])),o=s.crossProduct(t,r);return s.unitVector(o)}distanceTo(e,t){let r=this.computeNormal(e),o=e.getVertex(this.#e[0]),n=-(r.x*o.x+r.y*o.y+r.z*o.z);return Math.abs(r.x*t.x+r.y*t.y+r.z*t.z+n)/Math.sqrt(r.x**2+r.y**2+r.z**2)}getFarthestPoint(e,t){if(!(t.length>0))throw Error("pointIndices must contain at least one entry");let r=t[0],o=0;for(let n of t){let a=e.getVertex(n),c=this.distanceTo(e,a);c>o&&(o=c,r=n);}return r}flipNormal(){return new i([this.#e[2],this.#e[1],this.#e[0]])}getVerticeReference(e){return this.#e[e]}static addPointsFromTrianglesToMap(e,t){for(let r=0;r<t.length;r++){for(let o=0;o<2;o++)p.addToMap(e,t[r].getVerticeReference(o),t[r].getVerticeReference(o+1));p.addToMap(e,t[r].getVerticeReference(2),t[r].getVerticeReference(0));}}static createPyramidFromBoundaryPoints(e,t){let r=[];for(let o=0;o<e.length-1;o++){let n=new this([t,e[o],e[o+1]]);r.push(n);}return r.push(new this([t,e[e.length-1],e[0]])),r}copy(){let e=[];for(let t of this.#e)e.push(t);return new i(e)}getDistinctIdentifier(){return this.#e[0].toString()+this.#e[1].toString()+this.#e[2].toString()}};var g=class{#e;#t;constructor(e,t){this.#e=e,this.#t=t;}get p1(){return this.#e}get p2(){return this.#t}isEqual(e){return this===e||this.#e===e.p1&&this.#t===e.p2||this.#e===e.p2&&this.#t==e.p1}distanceToPoint(e){let t=s.sub(e,this.#e),r=s.sub(this.#t,this.#e);return s.magnitude(s.crossProduct(t,r))/s.magnitude(r)}};var m=class i{array;constructor(e){this.array=e,e==null&&(this.array=[]);}getVertex(e){return this.array[e]}static generateFieldFromMatrixOfPoints(e){let t=new i([]);for(let r of e)t.array.push(new s(r[0],r[1],r[2]));return t}generateRandomPointsInSphere(e,t){this.array=[];for(let r=0;r<t;r++)this.array.push(s.generateVectorInSphere(e));}getTriangleUpspace(e,t){let r=[];for(let o of t)o==e.getVerticeReference(0)||o==e.getVerticeReference(1)||o==e.getVerticeReference(2)||e.doesUpspaceContain(this,o)&&r.push(o);return r}getTrianglesWithPointInUpspace(e,t){let r=[],o;for(let n=0;n<e.length;n++)o=e[n],o.doesUpspaceContain(this,t)&&r.push(o);return r}getTriangleIndicesWithPointInUpspace(e,t){let r=[],o;for(let n=0;n<e.length;n++)o=e[n],o.doesUpspaceContain(this,t)&&r.push(n);return r}getTrianglesUpspaces(e,t){let r=[];for(let o of e)r.push(this.getTriangleUpspace(o,t));return r=p.combineArrays(r),p.noDuplicates(r)}getTrianglesUpspaces_Fast(e,t){let r=[];for(let o of e){let n=[];for(let a of t){if(a==o.getVerticeReference(0)||a==o.getVerticeReference(1)||a==o.getVerticeReference(2))continue;let c=this.getVertex(a),l=this.getVertex(o.getVerticeReference(0)),h=c.x-l.x,u=c.y-l.y,d=c.z-l.z,V=o.computeNormal(this);h*V.x+u*V.y+d*V.z;o.doesUpspaceContain(this,a)&&n.push(a);}r.push(n);}return r=p.combineArrays(r),p.noDuplicates(r)}getPointsAtIndices(e,t){let r=[];for(let o of t)r.push(e.array[o]);return r}getAverageDistanceBetweenPointsAndTriangles(e,t){let r=[];for(let o of t){let n=0;for(let c of e)n+=c.distanceTo(this,this.getVertex(o));let a=n/e.length;r.push(a);}return r}getFarthestPointFromTriangles(e,t){let r=this.getFarthestPointsFromTriangles(e,t),o=this.getAverageDistanceBetweenPointsAndTriangles(e,r),n=p.getIndexOfArrayMax(o);if(n==null)throw Error("Bad error");return r[n]}getFarthestPointFromTriangles_Fast(e,t){let r=t[0],o=-1/0;for(let n of t){let a=0,c=this.getVertex(n);for(let l of e){let h=l.computeNormal(this),u=this.getVertex(l.getVerticeReference(0)),d=-(h.x*u.x+h.y*u.y+h.z*u.z);a+=(h.x*c.x+h.y*c.y+h.z*c.z+d)/(h.x**2+h.y**2+h.z**2);}a>o&&(o=a,r=n);}return r}getFarthestPointsFromTriangles(e,t){let r=[];for(let n of e)r.push(n.getFarthestPoint(this,t));return r}getFarthestVectorFromVector(e){let t=0,o=-1,n=this.array[e];for(let a=0;a<this.array.length;a++){let c=s.distanceBetweenVectors(this.array[a],n);c>t&&(t=c,this.array[a],o=a);}if(o==-1)throw Error("no farthest distance point found at all");return o}calculateLargestTriangleFromField(){let e=this.lowestVectorInField(),t=this.getFarthestVectorFromVector(e),r=new g(this.array[e],this.array[t]),o=this.calculateFarthestPoint(r);return new f([e,t,o])}calculateFarthestPoint(e){let t=0,o=-1;for(let n=0;n<this.array.length;n++){if(s.isVectorEqual(this.array[n],e.p1)||s.isVectorEqual(this.array[n],e.p2))continue;let c=e.distanceToPoint(this.array[n]);t<c&&(this.array[n],t=c,o=n);}if(o==-1)throw Error("no farthest point found");return o}lowestVectorInField(){if(this.array.length==0)throw Error("array length is 0");let e=this.array[0],t=0;for(let r=0;r<this.array.length;r++)e.x>this.array[r].x&&(e=this.array[r],t=r,r=0);return t}findVectorWithLowestZ(){let e=1/0,t=-1;for(let r=0;r<this.array.length;r++){let o=this.array[r];o.z<e&&(e=o.z,t=r);}if(t==-1)throw Error("no vector found!");return t}findVectorWithHighestZ(){let e=-1/0,t=-1;for(let r=0;r<this.array.length;r++){let o=this.array[r];o.z>e&&(e=o.z,t=r);}if(t==-1)throw Error("no vector found!");return t}moveEntireField(e){let t=[];for(let r=0;r<this.array.length;r++)t.push(s.add(this.array[r],e));return new i(t)}copy(){let e=[];for(let t of this.array)e.push(new s(t.x,t.y,t.z));return new i(e)}get numPoints(){return this.array.length}};var y=class i{#e;#t;constructor(e,t){this.#e=e,this.#t=t;}worldPositionOfDirection(){return s.add(this.#e,this.#t)}copy(){return new i(this.#e.copy(),this.#t.copy())}get position(){return this.#e}get direction(){return this.#t}};var b=class i{#e;#t;constructor(e,t){if(!(e instanceof m))throw Error("vertices is not an instance of Field");if(!Array.isArray(t))throw Error("triangles is not an array");this.#e=e,this.#t=t,e==null&&(this.#e=new m([])),t==null&&(this.#t=[]);}calculateTriangleNormalVector(e){if(!(e instanceof f))throw Error("triangle is not an instance of Triangle");let t=e.computeCentroid(this.#e),r=e.computeNormal(this.#e);return new y(t,r)}calculateTriangleNormalVectors(){this.#e;let t=[];for(let r of this.#t)t.push(this.calculateTriangleNormalVector(r));return t}mapTrianglesToNormalVectors(e){if(this.numTriangles!==e.length)throw Error("number of triangles does not equal number of normal vectors");let t=new Map;for(let r=0;r<this.numTriangles;r++)t.set(this.getTriangle(r).getDistinctIdentifier(),e[r]);return t}findTrianglesNormalVectorsFromMap(e){let t=[];for(let r=0;r<this.numTriangles;r++){let o=this.getTriangle(r).getDistinctIdentifier();e.has(o)&&t.push(e.get(o));}return t}copy(){let e=[];for(let t of this.#t)e.push(t.copy());return new i(this.#e.copy(),e)}get numPoints(){return this.#e.numPoints}get numTriangles(){return this.#t.length}getVertex(e){if(!Number.isSafeInteger(e))throw Error("index is not a safe integer");return this.#e.getVertex(e)}getTriangle(e){if(!Number.isSafeInteger(e))throw Error("index is not a safe integer");return this.#t[e]}set vertices(e){if(!(e instanceof m))throw Error("vertices must be an instance of Field");this.#e=e;}set triangles(e){if(!Array.isArray(e))throw Error("triangles is not an array");this.#t=e;}};var F=class i{#e;#t;#r;constructor(e,t,r){this.#e=e,this.#r=r,this.#t=t;}calculateObservedColor(e){let r=this.#e.multiplyByNumber(this.#r).multiplyByNumber(1/255),n=e.multiplyByNumber(1/255).elementWiseMultiplication(r);return n=n.multiplyByNumber(255),n}copy(){return new i(this.#e.copy(),this.#t.copy(),this.#r)}};var C=class i{static convexHullIterativeProcess(e,t,r){t=[...t];let o=e.getTrianglesUpspaces_Fast(t,r),n=o[0];if(o.length==1)n=o[0];else {if(o.length==0)return [];n=e.getFarthestPointFromTriangles_Fast(t,o);}if(n===void 0)throw Error("LOOK AT THIS CODE LINE IDK - 12/10/2025 - when i took on the task of converting it all to TS");let a=e.getTriangleIndicesWithPointInUpspace(t,n),c=e.getTrianglesWithPointInUpspace(t,n),l=new Map;f.addPointsFromTrianglesToMap(l,c);let h=p.getNodesOnOutsideOfCounterClockwiseGraph(l,1e5),u=f.createPyramidFromBoundaryPoints(h,n);return t=p.removeIndicesFromArray(t,a),t=i.addTrianglesToTrianglesArray(t,u),t}static addTrianglesToTrianglesArray(e,t){let r=[];e.forEach(o=>{r.push(o.copy());});for(let o of t)r.push(o);return r}static generateConvexMesh(e,t){let n;n=[e.calculateLargestTriangleFromField()],n.push(n[0].flipNormal());let a=p.arrayOfIndices(e.numPoints);n=this.convexHullIterativeProcess(e,n,a);for(let c=0;c<t;c++){let l=this.convexHullIterativeProcess(e,n,a);if(l.length==0)return new b(e,n);n=l;}return new b(e,n)}};var N=class i{#e;#t;#r;#o;constructor(e,t,r,o){this.#e=e,e instanceof s||(this.#e=new s(0,0,0)),this.#t=t,t instanceof s||(this.#t=new s(0,0,0)),this.#r=r,r instanceof s||(this.#r=new s(0,0,0)),this.#o=o,o==null&&(this.#o=.01);}update(e){this.#e=s.add(this.#e,s.scalarMult(this.#t,e)),this.#t=s.add(this.#t,s.scalarMult(this.#r,e)),this.#t=s.scalarMult(this.#t,1-this.#o);}get position(){return this.#e.copy()}get velocity(){return this.#t.copy()}get acceleration(){return this.#r.copy()}set position(e){if(!(e instanceof s))throw Error("Position input is not of type Vector");this.#e=e;}set velocity(e){if(!(e instanceof s))throw Error("Velocity input is not of type Vector");this.#t=e;}set acceleration(e){if(!(e instanceof s))throw Error("Acceleration input is not of type Vector");this.#r=e;}copy(){return new i(this.#e.copy(),this.#t.copy(),this.#r.copy(),this.#o)}};var E=class i{#e;#t;#r;#o;#n;#i;#s;constructor(e,t,r,o,n){this.#e=e,this.#t=s.unitVector(t),this.#r=r,this.#o=o,this.#n=n,this.#i=new s(0,1,0),this.#s=s.unitVector(s.crossProduct(this.#i,t));}get focalDistance(){return this.#o}setPosition(e){if(!(e instanceof s))throw Error("position is not an instance of Vector");this.#e.position=e;}putCameraAtCenterOfMeshCoordinateSystem(e){let t=e.copy();return t=this.shiftMeshIntoCameraSpace(t),t=this.projectMeshOntoCameraAxis(t),t}shiftMeshIntoCameraSpace(e){let t=[],r=e.copy();for(let o=0;o<e.numPoints;o++)t.push(s.sub(e.getVertex(o),this.#e.position));return r.vertices=new m(t),r}projectMeshOntoCameraAxis(e){let t=[],r=e.copy();for(let o=0;o<e.numPoints;o++){let n=e.getVertex(o),a=s.dotProduct(n,this.#s),c=s.dotProduct(n,this.#i),l=s.dotProduct(n,this.#t);t.push(new s(a,c,l));}return r.vertices=new m(t),r}rejectNegativeZValuesList(e){let t=[];for(let r=0;r<e.numPoints;r++)t.push(this.isVertexVisible(e.getVertex(r)));return t}isVertexVisible(e){return !(e.z<0)}copy(){return new i(this.#e.copy(),this.#t.copy(),this.#r,this.#o,this.#n)}pointAtPoint(e){if(!(e instanceof s))throw Error("point is not an instance of Vector");this.#t=s.unitVector(s.sub(e,this.#e.position));}log(){console.log("start camer log"),console.log(this.#e.position),console.log(this.#t),console.log("end camera log");}};var A=class i{#e;#t;constructor(e,t){this.#e=e,this.#t=t;}getLight(e){return this.#t[e]}getMesh(e){return this.#e[e]}copy(){return new i(this.#e.map(e=>e.copy()),this.#t.map(e=>e.copy()))}get numMeshes(){return this.#e.length}get numLights(){return this.#t.length}set meshes(e){if(!Array.isArray(e))throw Error("meshes is not an array");this.meshes=e;}};var w=class{acceleration;constructor(e){this.acceleration=e;}};var I=class extends w{currentTheta;constructor(e){super(e),this.currentTheta=0;}rotateCameraAroundPointOnXZPlane(e,t,r,o){let n=e.copy(),a=s.add(t,new s(Math.sin(this.currentTheta)*r,0,Math.cos(this.currentTheta)*r));return this.currentTheta+=o,n.setPosition(a),n.pointAtPoint(t),n}};var T=class{camera;scene;renParam;constructor(e,t,r){this.scene=e,this.camera=t,this.renParam=r;}graph(){for(let e=0;e<this.scene.numMeshes;e++)this.graphMesh(this.scene.getMesh(e));}graphMesh(e){this.preWork(),e=e.copy(),e=this.camera.putCameraAtCenterOfMeshCoordinateSystem(e),!this.renParam.isWindingOrderBackFaceCulling&&this.renParam.doBackFaceCulling&&(e=this.backFaceCulling_Normal(e));let t;if(this.renParam.isPerspective||(t=e.calculateTriangleNormalVectors()),e=this.applyProjection(e),this.renParam.isPerspective&&(t=e.calculateTriangleNormalVectors()),this.renParam.isWindingOrderBackFaceCulling&&this.renParam.doBackFaceCulling){let r=e.mapTrianglesToNormalVectors(t);e=this.backFaceCulling_WindingOrder(e),t=e.findTrianglesNormalVectorsFromMap(r);}this.renParam.doNormalVectors&&this.graphNormalVectors(e,t,this.renParam.normalVectorLength),e=this.meshToCanvas(e),this.renParam.doVertices&&this.graphVertices(e),this.renParam.doTriangles&&this.graphTriangles(e),this.postWork();}backFaceCulling_Normal(e){let t=new s(0,0,1),o=e.copy(),n=[],a=o.calculateTriangleNormalVectors();for(let c=0;c<e.numTriangles;c++){let l;this.renParam.isPerspective?l=s.sub(a[c].position,new s(0,0,0)).isDotProductLEThanX(a[c].direction,0):l=t.isDotProductLEThanX(a[c].direction,0),l&&n.push(e.getTriangle(c));}return o.triangles=n,o}backFaceCulling_WindingOrder(e){let t=e.copy(),r=[];for(let o=0;o<t.numTriangles;o++){let n=t.getTriangle(o),a=t.getVertex(n.getVerticeReference(0)),c=t.getVertex(n.getVerticeReference(1)),l=t.getVertex(n.getVerticeReference(2)),h=s.sub(c,a),u=s.sub(l,a);h.x*u.y-u.x*h.y>0&&r.push(n);}return t.triangles=r,t}orthographicProjectIndividualVector(e){return new s(e.x,e.y,this.camera.focalDistance)}perspectiveProjectIndividualVector(e){let t=this.camera.focalDistance/e.z,r=e.x*t,o=e.y*t,n=this.camera.focalDistance;return new s(r,o,n)}orthographicProjectNormalVectorIntoLine(e,t){let r=this.orthographicProjectIndividualVector(e.position),o=this.orthographicProjectIndividualVector(s.add(s.scalarMult(e.direction,t),e.position));return new g(r,o)}perspectiveProjectNormalVectorIntoLine(e,t){let r=this.perspectiveProjectIndividualVector(e.position),o=this.perspectiveProjectIndividualVector(s.add(s.scalarMult(e.direction,t),e.position));return new g(r,o)}projectNormalVectorsIntoLines(e,t){let r=[];for(let o of e)this.renParam.isPerspective&&r.push(this.perspectiveProjectNormalVectorIntoLine(o,t)),this.renParam.isPerspective||r.push(this.orthographicProjectNormalVectorIntoLine(o,t));return r}applyProjection(e){let t=e.copy(),r=[];for(let n=0;n<t.numPoints;n++){let a,c=t.getVertex(n);this.renParam.isPerspective?a=this.perspectiveProjectIndividualVector(c):a=this.orthographicProjectIndividualVector(c),r.push(a);}let o=new m(r);return t.vertices=o,t}};var z=class extends T{#e;#t;constructor(e,t,r,o,n){super(e,r,o),n.createCanvas(t.x,t.y),this.#t=n,this.#e=n.createGraphics(t.x,t.y);}preWork(){this.#e.clear(),this.#e.background(140);}postWork(){this.#t.image(this.#e,0,0);}meshToCanvas(e){let t=e.copy(),r=[];for(let o=0;o<t.numPoints;o++)r.push(this.calculateCanvasPos(e.getVertex(o)));return e.vertices=new m(r),e}calculateCanvasPos(e){return s.add(new s(this.#e.width/2,this.#e.height/2,0),e)}graphNormalVectors(e,t,r){let o=this.projectNormalVectorsIntoLines(t,r),n=this.linesToCanvas(o);this.graphLines(n,this.#t.color(0));}linesToCanvas(e){let t=[];for(let r of e)t.push(new g(this.calculateCanvasPos(r.p1),this.calculateCanvasPos(r.p2)));return t}graphVertices(e){for(let t=0;t<e.numPoints;t++)this.graphVertex(e.getVertex(t),3);}graphVertex(e,t){this.#e.stroke(0),this.#e.fill(0),this.#e.circle(e.x,e.y,t);}graphVisibleVertex(e,t){this.camera.isVertexVisible(e)&&this.graphVertex(e,t);}graphVisibleVertices(e,t){for(let r=0;r<e.numPoints;r++)this.graphVisibleVertex(e.getVertex(r),t);}graphTriangle(e,t){let r=e.getVertex(t.getVerticeReference(0)),o=e.getVertex(t.getVerticeReference(1)),n=e.getVertex(t.getVerticeReference(2));this.#e.strokeJoin(this.#t.ROUND),this.#e.noFill(),this.#e.triangle(r.x,r.y,o.x,o.y,n.x,n.y);}graphTriangles(e){this.#e.stroke(this.#t.color(0));for(let t=0;t<e.numTriangles;t++)this.graphTriangle(e,e.getTriangle(t));}graphLines(e,t){for(let r of e)this.graphLine(r,t);}graphLine(e,t){this.graphBetweenTwoPoints(e.p1,e.p2,t);}graphBetweenTwoPoints(e,t,r){this.#e.stroke(r),this.#e.line(e.x,e.y,t.x,t.y);}copy(){}};var x=class{#e;#t;#r;#o;#n;#i;#s;#a;#c;#l;#h;#u;constructor({doBackFaceCulling:e=true,doOutline:t=true,doFill:r=true,doVertices:o=false,doNormalVectors:n=false,doShadingWithLighting:a=true,lineWidth:c=1,pointRadius:l=3,isPerspective:h=true,doTriangles:u=true,isWindingOrderBackFaceCulling:d=true,normalVectorLength:V=25}={}){this.#e=e,this.#t=t,this.#r=r,this.#o=o,this.#n=n,this.#i=a,this.#s=c,this.#a=l,this.#c=h,this.#l=u,this.#h=d,this.#u=V;}get doBackFaceCulling(){return this.#e}get doOutline(){return this.#t}get doFill(){return this.#r}get doVertices(){return this.#o}get doNormalVectors(){return this.#n}get doShadingWithLighting(){return this.#i}get lineWidth(){return this.#s}get pointRadius(){return this.#a}get isPerspective(){return this.#c}get doTriangles(){return this.#l}get isWindingOrderBackFaceCulling(){return this.#h}get normalVectorLength(){return this.#u}set doBackFaceCulling(e){if(typeof e!="boolean")throw new TypeError("doBackFaceCulling must be boolean");this.#e=e;}set doOutline(e){if(typeof e!="boolean")throw new TypeError("doOutline must be boolean");this.#t=e;}set doFill(e){if(typeof e!="boolean")throw new TypeError("doFill must be boolean");this.#r=e;}set doVertices(e){if(typeof e!="boolean")throw new TypeError("doVertices must be boolean");this.#o=e;}set doNormalVectors(e){if(typeof e!="boolean")throw new TypeError("doNormalVectors must be boolean");this.#n=e;}set doShadingWithLighting(e){if(typeof e!="boolean")throw new TypeError("doShadingWithLighting must be boolean");this.#i=e;}set lineWidth(e){if(typeof e!="number"||!Number.isFinite(e)||e<=0)throw new TypeError("lineWidth must be a positive finite number");this.#s=e;}set pointRadius(e){if(typeof e!="number"||!Number.isFinite(e)||e<=0)throw new TypeError("pointRadius must be a positive finite number");this.#a=e;}set isPerspective(e){if(typeof e!="boolean")throw new TypeError("isPerspective must be boolean");this.#c=e;}set doTriangles(e){if(typeof e!="boolean")throw new TypeError("doTriangles must be boolean");this.#l=e;}set isWindingOrderBackFaceCulling(e){if(typeof e!="boolean")throw new TypeError("isWindingOrderBackFaceCulling must be boolean");this.#h=e;}set normalVectorLength(e){if(typeof e!="number"||!Number.isFinite(e)||e<=0)throw new TypeError("normalVectorLength must be a positive finite number");this.#u=e;}};var L=class extends x{};exports.Camera=E;exports.Field=m;exports.Light=F;exports.Mesh=b;exports.MeshGenerator=C;exports.PhysicsBody=N;exports.Scene=A;exports.Vector=s;exports.p5CameraMover=I;exports.p5MeshRenderer=z;exports.p5RenderParameters=L;return exports;})({});